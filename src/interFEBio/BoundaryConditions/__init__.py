# Auto-generated by codegen.generator
from __future__ import annotations

from dataclasses import dataclass, field, fields
from typing import Any, Optional
import xml.etree.ElementTree as ET

def _indent(element: ET.Element, level: int = 0) -> None:
    '''Recursively indent an XML tree for pretty-printing.'''

    children = list(element)
    if children:
        if not element.text or not element.text.strip():
            element.text = '\n' + '  ' * (level + 1)
        for child in children:
            _indent(child, level + 1)
            if not child.tail or not child.tail.strip():
                child.tail = '\n' + '  ' * (level + 1)
        if not children[-1].tail or not children[-1].tail.strip():
            children[-1].tail = '\n' + '  ' * level
    elif level and (not element.tail or not element.tail.strip()):
        element.tail = '\n' + '  ' * level

class FEBioEntity:
    '''Base class for generated FEBio bindings.

    Attributes:
        fe_class: Name of the FEBio class represented by the binding.
        xml_tag: XML tag used for serialisation.
        xml_section: FEBio section that hosts the entity.
    '''

    fe_class: str = ''
    xml_tag: str = ''
    xml_section: str = ''

    def to_xml_element(self, name: str | None = None, *, tag_override: str | None = None) -> ET.Element:
        '''Serialise the entity into an XML element.

        Args:
            name: Optional name attribute for the FEBio element.

        Returns:
            Constructed XML element.
        '''

        tag = tag_override or self.xml_tag or 'bc'
        element = ET.Element(tag)
        element.set('type', self.fe_class)
        if name:
            element.set('name', name)
        for field_info in fields(self):
            if field_info.name in {'fe_class', 'xml_tag', 'xml_section'}:
                continue
            value = getattr(self, field_info.name)
            if value is None:
                continue
            metadata = field_info.metadata or {}
            param_name = metadata.get('fe_name', field_info.name)
            if metadata.get('is_property'):
                self._append_property_element(element, param_name, value)
                continue
            # Parameters are written as direct child tags instead of <param name="...">.
            param_element = ET.SubElement(element, param_name)
            param_element.text = str(value)
        return element

    def _append_property_element(self, parent: ET.Element, tag: str, value: Any) -> None:
        '''Append a property element handling FEBioEntity nesting.'''

        if isinstance(value, FEBioEntity):
            child = value.to_xml_element(tag_override=tag)
            parent.append(child)
            return
        if isinstance(value, (list, tuple)):
            for item in value:
                if item is None:
                    continue
                self._append_property_element(parent, tag, item)
            return
        prop_element = ET.SubElement(parent, tag)
        prop_element.text = str(value)

    def to_xml_string(self, name: str | None = None) -> str:
        '''Return the XML representation as a string.

        Args:
            name: Optional name attribute for the FEBio element.

        Returns:
            XML string representing the entity.
        '''

        element = self.to_xml_element(name=name)
        _indent(element)
        return ET.tostring(element, encoding='unicode')

from ..Core import Vec3d
from ..common.regions import NodeSetRef, SurfaceRef, coerce_nodeset, coerce_surface

class FEBoundaryCondition(FEBioEntity):
    pass

class FECoreClass(FEBioEntity):
    pass

class mat3d(FEBioEntity):
    pass

class tens3drs(FEBioEntity):
    pass

@dataclass
class FENodalBC(FEBoundaryCondition):
    node_set: Optional[NodeSetRef] = field(
        default=None, metadata={'fe_name': 'node_set', 'is_property': True}
    )

    def __post_init__(self) -> None:
        if self.node_set is not None:
            self.node_set = coerce_nodeset(self.node_set)

class FEFixedBC(FENodalBC):
    pass

class FEPrescribedNodeSet(FENodalBC):
    pass

@dataclass
class FEPrescribedSurface(FEBoundaryCondition):
    surface: Optional[SurfaceRef] = field(
        default=None, metadata={'fe_name': 'surface', 'is_property': True}
    )

    def __post_init__(self) -> None:
        if self.surface is not None:
            self.surface = coerce_surface(self.surface)


__all__ = [
    'FEBCPrescribedDeformation',
    'FEBCPrescribedDeformation2O',
    'FEBCRigidDeformation',
    'FEFixedDisplacement',
    'FEFixedRotation',
    'FEFixedShellDisplacement',
    'FELinearConstraint',
    'FELinearConstraintDOF',
    'FEPrescribedDisplacement',
    'FEPrescribedNormalDisplacement',
    'FEPrescribedRotation',
    'FEPrescribedShellDisplacement',
    'FERigidNodeSet',
    'Vec3d',
    'NodeSetRef',
    'SurfaceRef',
    'FENodalBC',
    'FEFixedBC',
    'FEPrescribedNodeSet',
    'FEPrescribedSurface',
]

@dataclass
class FEBCPrescribedDeformation(FEPrescribedNodeSet):
    scale: Optional[float] = field(default=None, metadata={'fe_name': 'scale'})
    f: Optional[mat3d] = field(default=None, metadata={'fe_name': 'F'})
    fe_class: str = field(init=False, default='prescribed deformation')
    xml_tag: str = field(init=False, default='bc')
    xml_section: str = field(init=False, default='Boundary Conditions')

@dataclass
class FEBCPrescribedDeformation2O(FEPrescribedNodeSet):
    scale: Optional[float] = field(default=None, metadata={'fe_name': 'scale'})
    f: Optional[mat3d] = field(default=None, metadata={'fe_name': 'F'})
    g: Optional[tens3drs] = field(default=None, metadata={'fe_name': 'G'})
    reference: Optional[int] = field(default=None, metadata={'fe_name': 'reference'})
    fe_class: str = field(init=False, default='prescribed deformation 2O')
    xml_tag: str = field(init=False, default='bc')
    xml_section: str = field(init=False, default='Boundary Conditions')

@dataclass
class FEBCRigidDeformation(FEPrescribedNodeSet):
    pos: Optional[Vec3d] = field(default=None, metadata={'fe_name': 'pos'})
    rot: Optional[Vec3d] = field(default=None, metadata={'fe_name': 'rot'})
    fe_class: str = field(init=False, default='rigid deformation')
    xml_tag: str = field(init=False, default='bc')
    xml_section: str = field(init=False, default='Boundary Conditions')

@dataclass
class FEFixedDisplacement(FEFixedBC):
    x_dof: Optional[bool] = field(default=None, metadata={'fe_name': 'x_dof', 'long_name': 'x-displacement'})
    y_dof: Optional[bool] = field(default=None, metadata={'fe_name': 'y_dof', 'long_name': 'y-displacement'})
    z_dof: Optional[bool] = field(default=None, metadata={'fe_name': 'z_dof', 'long_name': 'z-displacement'})
    fe_class: str = field(init=False, default='zero displacement')
    xml_tag: str = field(init=False, default='bc')
    xml_section: str = field(init=False, default='Boundary Conditions')

@dataclass
class FEFixedRotation(FEFixedBC):
    u_dof: Optional[Any] = field(default=None, metadata={'fe_name': 'u_dof', 'long_name': 'x-rotation'})
    v_dof: Optional[Any] = field(default=None, metadata={'fe_name': 'v_dof', 'long_name': 'y-rotation'})
    w_dof: Optional[Any] = field(default=None, metadata={'fe_name': 'w_dof', 'long_name': 'z-rotation'})
    fe_class: str = field(init=False, default='zero rotation')
    xml_tag: str = field(init=False, default='bc')
    xml_section: str = field(init=False, default='Boundary Conditions')

@dataclass
class FEFixedShellDisplacement(FEFixedBC):
    sx_dof: Optional[bool] = field(default=None, metadata={'fe_name': 'sx_dof', 'long_name': 'sx-displacement'})
    sy_dof: Optional[bool] = field(default=None, metadata={'fe_name': 'sy_dof', 'long_name': 'sy-displacement'})
    sz_dof: Optional[bool] = field(default=None, metadata={'fe_name': 'sz_dof', 'long_name': 'sz-displacement'})
    fe_class: str = field(init=False, default='zero shell displacement')
    xml_tag: str = field(init=False, default='bc')
    xml_section: str = field(init=False, default='Boundary Conditions')

@dataclass
class FELinearConstraint(FEBoundaryCondition):
    offset: Optional[float] = field(default=None, metadata={'fe_name': 'offset'})
    child_dof: Optional[int] = field(default=None, metadata={'fe_name': 'child_dof', 'is_property': True})
    fe_class: str = field(init=False, default='linear constraint')
    xml_tag: str = field(init=False, default='bc')
    xml_section: str = field(init=False, default='Boundary Conditions')

@dataclass
class FELinearConstraintDOF(FECoreClass):
    dof: Optional[int] = field(default=None, metadata={'fe_name': 'dof', 'range': '$(dof_list)', 'enum': '$(dof_list)'})
    node: Optional[int] = field(default=None, metadata={'fe_name': 'node'})
    value: Optional[float] = field(default=None, metadata={'fe_name': 'value'})
    fe_class: str = field(init=False, default='child_dof')
    xml_tag: str = field(init=False, default='bc')
    xml_section: str = field(init=False, default='Boundary Conditions')

@dataclass
class FEPrescribedDisplacement(FENodalBC):
    dof: Optional[int] = field(default=None, metadata={'fe_name': 'dof', 'range': '$(dof_list:displacement)', 'enum': '$(dof_list:displacement)'})
    value: Optional[float] = field(default=None, metadata={'fe_name': 'value', 'units': 'UNIT_LENGTH'})
    relative: Optional[bool] = field(default=None, metadata={'fe_name': 'relative'})
    fe_class: str = field(init=False, default='prescribed displacement')
    xml_tag: str = field(init=False, default='bc')
    xml_section: str = field(init=False, default='Boundary Conditions')

@dataclass
class FEPrescribedNormalDisplacement(FEPrescribedSurface):
    scale: Optional[float] = field(default=None, metadata={'fe_name': 'scale'})
    surface_hint: Optional[int] = field(default=None, metadata={'fe_name': 'surface_hint'})
    relative: Optional[bool] = field(default=None, metadata={'fe_name': 'relative'})
    fe_class: str = field(init=False, default='normal displacement')
    xml_tag: str = field(init=False, default='bc')
    xml_section: str = field(init=False, default='Boundary Conditions')

@dataclass
class FEPrescribedRotation(FEBoundaryCondition):
    dof: Optional[int] = field(default=None, metadata={'fe_name': 'dof', 'range': '$(dof_list:rotation)', 'enum': '$(dof_list:rotation)'})
    value: Optional[float] = field(default=None, metadata={'fe_name': 'value', 'units': 'UNIT_RADIAN'})
    relative: Optional[bool] = field(default=None, metadata={'fe_name': 'relative'})
    fe_class: str = field(init=False, default='prescribed rotation')
    xml_tag: str = field(init=False, default='bc')
    xml_section: str = field(init=False, default='Boundary Conditions')

@dataclass
class FEPrescribedShellDisplacement(FENodalBC):
    dof: Optional[int] = field(default=None, metadata={'fe_name': 'dof', 'range': '$(dof_list:shell displacement)', 'enum': '$(dof_list:shell displacement)'})
    value: Optional[float] = field(default=None, metadata={'fe_name': 'value', 'units': 'UNIT_LENGTH'})
    relative: Optional[bool] = field(default=None, metadata={'fe_name': 'relative'})
    fe_class: str = field(init=False, default='prescribed shell displacement')
    xml_tag: str = field(init=False, default='bc')
    xml_section: str = field(init=False, default='Boundary Conditions')

@dataclass
class FERigidNodeSet(FENodalBC):
    rb: Optional[int] = field(default=None, metadata={'fe_name': 'rb'})
    clamp_shells: Optional[bool] = field(default=None, metadata={'fe_name': 'clamp_shells'})
    fe_class: str = field(init=False, default='rigid')
    xml_tag: str = field(init=False, default='bc')
    xml_section: str = field(init=False, default='Boundary Conditions')
