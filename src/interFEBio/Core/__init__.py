# Auto-generated by codegen.generator
from __future__ import annotations

from dataclasses import dataclass, field, fields
from typing import Any, Optional
import xml.etree.ElementTree as ET

def _indent(element: ET.Element, level: int = 0) -> None:
    '''Recursively indent an XML tree for pretty-printing.'''

    children = list(element)
    if children:
        if not element.text or not element.text.strip():
            element.text = '\n' + '  ' * (level + 1)
        for child in children:
            _indent(child, level + 1)
            if not child.tail or not child.tail.strip():
                child.tail = '\n' + '  ' * (level + 1)
        if not children[-1].tail or not children[-1].tail.strip():
            children[-1].tail = '\n' + '  ' * level
    elif level and (not element.tail or not element.tail.strip()):
        element.tail = '\n' + '  ' * level

class FEBioEntity:
    '''Base class for generated FEBio bindings.

    Attributes:
        fe_class: Name of the FEBio class represented by the binding.
        xml_tag: XML tag used for serialisation.
        xml_section: FEBio section that hosts the entity.
    '''

    fe_class: str = ''
    xml_tag: str = ''
    xml_section: str = ''

    def to_xml_element(self, name: str | None = None, *, tag_override: str | None = None) -> ET.Element:
        '''Serialise the entity into an XML element.

        Args:
            name: Optional name attribute for the FEBio element.

        Returns:
            Constructed XML element.
        '''

        tag = tag_override or self.xml_tag or 'bc'
        element = ET.Element(tag)
        element.set('type', self.fe_class)
        if name:
            element.set('name', name)
        for field_info in fields(self):
            if field_info.name in {'fe_class', 'xml_tag', 'xml_section'}:
                continue
            value = getattr(self, field_info.name)
            if value is None:
                continue
            metadata = field_info.metadata or {}
            param_name = metadata.get('fe_name', field_info.name)
            if metadata.get('is_property'):
                self._append_property_element(element, param_name, value)
                continue
            # Parameters are written as direct child tags instead of <param name="...">.
            param_element = ET.SubElement(element, param_name)
            param_element.text = str(value)
        return element

    def _append_property_element(self, parent: ET.Element, tag: str, value: Any) -> None:
        '''Append a property element handling FEBioEntity nesting.'''

        if isinstance(value, FEBioEntity):
            child = value.to_xml_element(tag_override=tag)
            parent.append(child)
            return
        if isinstance(value, (list, tuple)):
            for item in value:
                if item is None:
                    continue
                self._append_property_element(parent, tag, item)
            return
        prop_element = ET.SubElement(parent, tag)
        prop_element.text = str(value)

    def to_xml_string(self, name: str | None = None) -> str:
        '''Return the XML representation as a string.

        Args:
            name: Optional name attribute for the FEBio element.

        Returns:
            XML string representing the entity.
        '''

        element = self.to_xml_element(name=name)
        _indent(element)
        return ET.tostring(element, encoding='unicode')

@dataclass
class Vec3d:
    x: float = 0.0
    y: float = 0.0
    z: float = 0.0

    def __str__(self) -> str:
        return f"{self.x}, {self.y}, {self.z}"

class FEMat3dValuator(FEBioEntity):
    pass

class FEMat3dsValuator(FEBioEntity):
    pass

class mat3d(FEBioEntity):
    pass

class mat3ds(FEBioEntity):
    pass

__all__ = [
    'FEConstValueMat3d',
    'FEConstValueMat3ds',
    'FEMappedValueMat3d',
    'FEMappedValueMat3ds',
    'FEMat3dCylindricalMap',
    'FEMat3dLocalElementMap',
    'FEMat3dPolarMap',
    'FEMat3dSphericalAngleMap',
    'FEMat3dSphericalMap',
    'FEMat3dVectorMap',
]

@dataclass
class FEConstValueMat3d(FEMat3dValuator):
    const: Optional[mat3d] = field(default=None, metadata={'fe_name': 'const'})
    fe_class: str = 'const'
    xml_tag: str = ''
    xml_section: str = ''

@dataclass
class FEConstValueMat3ds(FEMat3dsValuator):
    const: Optional[mat3ds] = field(default=None, metadata={'fe_name': 'const'})
    fe_class: str = 'const'
    xml_tag: str = ''
    xml_section: str = ''

@dataclass
class FEMappedValueMat3d(FEMat3dValuator):
    map: Optional[str] = field(default=None, metadata={'fe_name': 'map'})
    fe_class: str = 'map'
    xml_tag: str = ''
    xml_section: str = ''

@dataclass
class FEMappedValueMat3ds(FEMat3dsValuator):
    map: Optional[str] = field(default=None, metadata={'fe_name': 'map'})
    fe_class: str = 'map'
    xml_tag: str = ''
    xml_section: str = ''

@dataclass
class FEMat3dCylindricalMap(FEMat3dValuator):
    center: Optional[Vec3d] = field(default=None, metadata={'fe_name': 'center'})
    axis: Optional[Vec3d] = field(default=None, metadata={'fe_name': 'axis'})
    vector: Optional[Vec3d] = field(default=None, metadata={'fe_name': 'vector'})
    fe_class: str = 'cylindrical'
    xml_tag: str = ''
    xml_section: str = ''

@dataclass
class FEMat3dLocalElementMap(FEMat3dValuator):
    local: Optional[int] = field(default=None, metadata={'fe_name': 'local'})
    fe_class: str = 'local'
    xml_tag: str = ''
    xml_section: str = ''

@dataclass
class FEMat3dPolarMap(FEMat3dValuator):
    center: Optional[Vec3d] = field(default=None, metadata={'fe_name': 'center'})
    axis: Optional[Vec3d] = field(default=None, metadata={'fe_name': 'axis'})
    vector1: Optional[Vec3d] = field(default=None, metadata={'fe_name': 'vector1'})
    vector2: Optional[Vec3d] = field(default=None, metadata={'fe_name': 'vector2'})
    radius1: Optional[float] = field(default=None, metadata={'fe_name': 'radius1'})
    radius2: Optional[float] = field(default=None, metadata={'fe_name': 'radius2'})
    fe_class: str = 'polar'
    xml_tag: str = ''
    xml_section: str = ''

@dataclass
class FEMat3dSphericalAngleMap(FEMat3dValuator):
    theta: Optional[float] = field(default=None, metadata={'fe_name': 'theta'})
    phi: Optional[float] = field(default=None, metadata={'fe_name': 'phi'})
    fe_class: str = 'angles'
    xml_tag: str = ''
    xml_section: str = ''

@dataclass
class FEMat3dSphericalMap(FEMat3dValuator):
    center: Optional[Vec3d] = field(default=None, metadata={'fe_name': 'center'})
    vector: Optional[Vec3d] = field(default=None, metadata={'fe_name': 'vector'})
    fe_class: str = 'spherical'
    xml_tag: str = ''
    xml_section: str = ''

@dataclass
class FEMat3dVectorMap(FEMat3dValuator):
    a: Optional[Vec3d] = field(default=None, metadata={'fe_name': 'a'})
    d: Optional[Vec3d] = field(default=None, metadata={'fe_name': 'd'})
    fe_class: str = 'vector'
    xml_tag: str = ''
    xml_section: str = ''
