# Auto-generated by codegen.generator
from __future__ import annotations

from dataclasses import dataclass, field, fields
from typing import Any, Optional
import xml.etree.ElementTree as ET

def _indent(element: ET.Element, level: int = 0) -> None:
    '''Recursively indent an XML tree for pretty-printing.'''

    children = list(element)
    if children:
        if not element.text or not element.text.strip():
            element.text = '\n' + '  ' * (level + 1)
        for child in children:
            _indent(child, level + 1)
            if not child.tail or not child.tail.strip():
                child.tail = '\n' + '  ' * (level + 1)
        if not children[-1].tail or not children[-1].tail.strip():
            children[-1].tail = '\n' + '  ' * level
    elif level and (not element.tail or not element.tail.strip()):
        element.tail = '\n' + '  ' * level

class FEBioEntity:
    '''Base class for generated FEBio bindings.

    Attributes:
        fe_class: Name of the FEBio class represented by the binding.
        xml_tag: XML tag used for serialisation.
        xml_section: FEBio section that hosts the entity.
    '''

    fe_class: str = ''
    xml_tag: str = ''
    xml_section: str = ''

    def to_xml_element(self, name: str | None = None, *, tag_override: str | None = None) -> ET.Element:
        '''Serialise the entity into an XML element.

        Args:
            name: Optional name attribute for the FEBio element.

        Returns:
            Constructed XML element.
        '''

        tag = tag_override or self.xml_tag or 'bc'
        element = ET.Element(tag)
        element.set('type', self.fe_class)
        if name:
            element.set('name', name)
        for field_info in fields(self):
            if field_info.name in {'fe_class', 'xml_tag', 'xml_section'}:
                continue
            value = getattr(self, field_info.name)
            if value is None:
                continue
            metadata = field_info.metadata or {}
            param_name = metadata.get('fe_name', field_info.name)
            if metadata.get('is_property'):
                self._append_property_element(element, param_name, value)
                continue
            # Parameters are written as direct child tags instead of <param name="...">.
            param_element = ET.SubElement(element, param_name)
            param_element.text = str(value)
        return element

    def _append_property_element(self, parent: ET.Element, tag: str, value: Any) -> None:
        '''Append a property element handling FEBioEntity nesting.'''

        if isinstance(value, FEBioEntity):
            child = value.to_xml_element(tag_override=tag)
            parent.append(child)
            return
        if isinstance(value, (list, tuple)):
            for item in value:
                if item is None:
                    continue
                self._append_property_element(parent, tag, item)
            return
        prop_element = ET.SubElement(parent, tag)
        prop_element.text = str(value)

    def to_xml_string(self, name: str | None = None) -> str:
        '''Return the XML representation as a string.

        Args:
            name: Optional name attribute for the FEBio element.

        Returns:
            XML string representing the entity.
        '''

        element = self.to_xml_element(name=name)
        _indent(element)
        return ET.tostring(element, encoding='unicode')

from ..common.regions import SurfaceRef, coerce_surface

class FEBoundaryCondition(FEBioEntity):
    pass

class FECoreClass(FEBioEntity):
    pass

class FEFixedBC(FEBioEntity):
    pass

class FENodalBC(FEBioEntity):
    pass

class FEPrescribedNodeSet(FEBioEntity):
    pass

class FEPrescribedSurface(FEBioEntity):
    pass

class FESurfaceConstraint(FEBioEntity):
    pass

class mat3d(FEBioEntity):
    pass

class tens3drs(FEBioEntity):
    pass

@dataclass
class FEContactInterface(FEBioEntity):
    primary: Optional[SurfaceRef] = field(
        default=None, metadata={'fe_name': 'primary', 'is_property': True}
    )
    secondary: Optional[SurfaceRef] = field(
        default=None, metadata={'fe_name': 'secondary', 'is_property': True}
    )

    def __post_init__(self) -> None:
        if self.primary is not None:
            self.primary = coerce_surface(self.primary)
        if self.secondary is not None:
            self.secondary = coerce_surface(self.secondary)


__all__ = [
    'FESlidingElasticInterface',
    'SurfaceRef',
    'FEContactInterface',
]

@dataclass
class FESlidingElasticInterface(FEContactInterface):
    laugon: Optional[int] = field(default=None, metadata={'fe_name': 'laugon', 'long_name': 'Enforcement method'})
    tolerance: Optional[float] = field(default=None, metadata={'fe_name': 'tolerance'})
    gaptol: Optional[float] = field(default=None, metadata={'fe_name': 'gaptol', 'units': 'UNIT_LENGTH'})
    penalty: Optional[float] = field(default=None, metadata={'fe_name': 'penalty'})
    auto_penalty: Optional[bool] = field(default=None, metadata={'fe_name': 'auto_penalty'})
    update_penalty: Optional[bool] = field(default=None, metadata={'fe_name': 'update_penalty'})
    two_pass: Optional[bool] = field(default=None, metadata={'fe_name': 'two_pass'})
    knmult: Optional[int] = field(default=None, metadata={'fe_name': 'knmult'})
    search_tol: Optional[float] = field(default=None, metadata={'fe_name': 'search_tol'})
    symmetric_stiffness: Optional[bool] = field(default=None, metadata={'fe_name': 'symmetric_stiffness'})
    search_radius: Optional[float] = field(default=None, metadata={'fe_name': 'search_radius', 'units': 'UNIT_LENGTH'})
    seg_up: Optional[int] = field(default=None, metadata={'fe_name': 'seg_up'})
    tension: Optional[bool] = field(default=None, metadata={'fe_name': 'tension'})
    minaug: Optional[int] = field(default=None, metadata={'fe_name': 'minaug'})
    maxaug: Optional[int] = field(default=None, metadata={'fe_name': 'maxaug'})
    node_reloc: Optional[bool] = field(default=None, metadata={'fe_name': 'node_reloc'})
    fric_coeff: Optional[float] = field(default=None, metadata={'fe_name': 'fric_coeff'})
    smooth_aug: Optional[bool] = field(default=None, metadata={'fe_name': 'smooth_aug'})
    flip_primary: Optional[bool] = field(default=None, metadata={'fe_name': 'flip_primary'})
    flip_secondary: Optional[bool] = field(default=None, metadata={'fe_name': 'flip_secondary'})
    shell_bottom_primary: Optional[bool] = field(default=None, metadata={'fe_name': 'shell_bottom_primary'})
    shell_bottom_secondary: Optional[bool] = field(default=None, metadata={'fe_name': 'shell_bottom_secondary'})
    offset: Optional[float] = field(default=None, metadata={'fe_name': 'offset', 'units': 'UNIT_LENGTH'})
    fe_class: str = field(init=False, default='sliding-elastic')
    xml_tag: str = field(init=False, default='material')
    xml_section: str = field(init=False, default='Contact')
